(* -*- compile-command: "ocamlbuild -classic-display treemachine.pdf" -*- *)

##verbatim '%' = MathPlugin.mathmode

open Prelude

(*** labels ***)

(*** doc ***)

let abstract = "A variant of Turing machines is introduced where the tape is replaced by a tree. The gain in structure is non-trivial and helps writing explicit constructions of machines."

let eilenberg = "{section"Eilenberg's machines"}

Eilenberg~{citation_needed} introduces a generic notion of machines which can be formalised as follows: a type of machine is given by a set <%X%> of {emph"data"} and a set <%Phi SUB sP\(X*X\)%> of {emph"instructions"}. Most of the times the instructions will be partial relations.

A machine of type <%(X,Phi)%> is given by a finite set <%Q%> of {emph"states"}, and subsets <%I%> and <%F%> of initial and finite states, as usual for automata. Transitions are labelled with relations of <%Phi%>. A path <%q_0%>,{ldots},<%q_n%> computes the composition of the relations on the successive edges. The machine itself compute the union of the relation computed by path from an initial state to a final state.

It does not change the expressiveness to close <%Phi%> by composition (<%i_1.i_2%>), union (<%i_1+i_2%>), identity (<%r1%>) and empty relation (<%r0%>){footnote"In Eilenberg's formulation, a more general kind of relation is considered, in order to be able, typically, to count the multiplicity of successful path. In that case, closure by <%r1%> ({emph"i.e."} adding {epsilon}-transitions) is not permitted."}. We shall use this fact implicitly.

In fact, relations computed by a machine of type <%(X,Phi)%> are exactly the relations in the sub-Kleene algebra of <%sP\(X*X\)%> generated by <%Phi%>: Thompson's~{citation_needed} and Kleene's~{citation_needed} work just as well as for finite automata. So Eilenberg machines are equivalent to regular expressions with alphabet <%Phi%>. Closing <%Phi%> by all the regular expression operations does not change what relation the machines compute, but it changes the complexity. Therefore we may refer to regular expressions as machines, while we will reserve the term {emph"instructions"} to star-free expressions.

Finite automata as well as Turing machines are examples of Eilenberg machines. (* arnaud: formellement il faut un moyen de produire l'entr'ee et lire la sortie. *)
"

let definition = "{section"Tree machines"}
Let us define the set <%T%> of trees as the set generated by the following grammar:
{displaymath begin array [`L;`Sep$~::=~$;`L;`Sep$~{mid}~$;`L] [
  array_line ["<%u%>,<%v%>"; "<%()%>"; "<%(u,v)%>"];
]end}
That is, <%T%> is the set of unlabelled binary trees.

We define the following partial functions on <%T%>:
{itemize [
  "<%delta x = (x,x)%>";
  "<%pi_1 x = y%>{qquad}(if <%exists z:T, x=(y,z)%>)";
  "<%pi_2 x = z%>{qquad}(if <%exists y:T, x=(y,z)%>)";
  "<%(i,j) x = (i y,j z)%>{qquad}(if <%x=(y,z)%>, for <%i%> and <%j%> partial functions on <%T%>)"; (* arnaud: il faut 'etendre ,ca aux relations en g'en'eral *)
  "<%epsilon x = ()%>";
  "<%() x = ()%>{qquad}(if <%x=()%>)";
]}

The set of instruction <%Phi%> is chosen to be the smallest set containing <%{delta;pi_1;pi_2;epsilon;()}%> and closed by <%(ph;ph)%>. Note that because these instruction are, in the language of categories, the unit, counit and functorial actions of the cartesian product and the terminal element, we can safely claim that they are sufficient to manipulate product.

We call tree machine a machine of type <%(T,Phi)%>. Notice that, contrary to Turing machines, tree machines are not parametrised by an alphabet: the tree structure offers enough power on its own.

The <%(ph,ph)%> instruction allows to observe and change sub-trees at an arbitrary but bounded depth.

{subsection"A language of guards and actions"}


As partial functions, the instructions of tree machines can be divided into a guard followed by a reconstruction function. We will adopt a suggestive notation <%gamma => alpha%> where <%gamma%> represents the guard and <%alpha%> the reconstruction function. We may use <%gamma_1 => alpha_1 | gamma_2 => alpha_2%>:
{itemize [
  "<%delta = x => (x,x)%>";
  "<%pi_1 = (x,\_) => x%>";
  "<%pi_2 = (\_,y) => y%>";
  "<%(i,j) = (gamma_i,gamma_j) => (alpha_i,alpha_j)%>{qquad}(for <%i=gamma_i=>gamma_j%> and <%j=gamma_j=>alpha_j%>)";
  "<%epsilon = \_ => ()%>";
  "<%() = () => ()%>";
]}

We require that the guards are linear (we can give a meaning to non-linear patterns but they would not have constant time). First we define pure guards <%gamma => emptyact%>, which only check that <%gamma%> matches the shape of the tree:
{itemize [
  "<%(x => emptyact) = r1%>";
  "<%(() => emptyact) = ()%>";
  "<%((gamma_1,gamma_2) => emptyact) = ((gamma_1 => emptyact),(gamma_2=>emptyact))%>";
]}
We now define generalised projections: instructions of the form <%gamma => x%> where <%x%> is a variable occurring in <%gamma%>:
{itemize [
  "<%(x => x) = r1%>";
  "<%((gamma_1,gamma_2) => x) = ((gamma_1 => x),(gamma_2=>emptyact)).pi_1%>{qquad}(when <%x%> occurs in <%gamma_1%>)";
  "<%((gamma_1,gamma_2) => x) = ((gamma_1 => emptyact),(gamma_2=>x)).pi_2%>{qquad}(when <%x%> occurs in <%gamma_2%>)";
]}
Finally, we can define generalised guard-and-action instructions <%gamma=>alpha%> (where the variables of <%alpha%> occur in <%gamma%>):
{itemize [
  "<%(gamma => ()) = (gamma => emptyact).epsilon%>";
  "<%(gamma => (alpha_1,alpha_2)) = delta.((gamma=>alpha_1),(gamma=>alpha_2))%>";
]}

For example:
{itemize [
  "<%sigma = ((x,y) => (y,x)) = delta.((r1,r1).pi_2,(r1,r1).pi_1)%>";
  "<%push = (((x,y),z) => (x,(y,z))) = delta.(((r1,r1).pi_1,r1).pi_1 , delta.(((r1,r1).pi_2,1).pi_1,((r1,r1),r1).pi_2))%>";
]}
We can apply the small optimisation that <%(1,1).pi_i = pi_i%> -- {emph"i.e."} we make sure that  <%(x,y) => x%> (resp. <%(x,y)=>y%>) is compiled to <%pi_1%> (resp. <%pi_2%>). The examples now read:
{itemize [
  "<%sigma = ((x,y) => (y,x)) = delta.(pi_2,pi_1)%>";
  "<%push = (((x,y),z) => (x,(y,z))) = delta.((pi_1,r1).pi_1 , delta.((pi_2,r1).pi_1,((r1,r1),r1).pi_2))%>";
]}
Further optimisation could consist in testing the shape of the pattern only once and program fast accessors as generalised projections which do not check side conditions. Combined with fact that <%(i,r1).pi_1 = i.pi_1%> (resp. <%(r1,j).pi_2 = j.pi_2%>) we can obtain a fairly compact form for <%push%>:
{itemize[
  "<%push = (((x,y),z) => (x,(y,z))) = ((r1,r1),r1).delta.(pi_1.pi_1 , delta.(pi_2.pi_1,pi_2))%>";
]}

{subsection"Constants"}


It will be useful to embed natural numbers in trees. Any embedding will do. We choose a binary encoding for the sake of compactness:
{itemize[
  "<%0 = ()%>";
  "<%2*n+1 = ((),n)%>";
  "<%2*n+2 = (((),()),n)%>"
 ]}

Commonly, we will want to tag a tree with a constant:
{itemize[
  "<%tag_u = x => (u,x)%>";
]}

{subsection"Zipper"}

See~{citation_needed}. Instructions to traverse a tree by focusing on arbitrary deep sub-trees.

{itemize [
  "<%open = x => ((),x)%>";
  "<%left = (x,(y,z)) => ((0,(x,z)),y)%>";
  "<%right = (x,(y,z)) => ((1,(x,y)),z)%>";
  "<%up = ((0,(x,z)),y) => (x,(y,z)) | ((1,(x,y)),z) => (x,(y,z))%>";
  "<%exit = ((),x) => x%>"
]}

The instruction <%zip = up^*.exit%> turns a focused tree back into a tree. Because it uses an iteration, it is not an instruction which has constant time. However, when it is known that the depth of the focused subtree is at most a constant <%n%> we can equivalently use the constant time instruction <%(r1+up^1+%{ldots}%+up^n).exit%>, we may still use <%zip%> as a shorthand.
"

let translations = "{section"Translations"}

{subsection"Turing machines as tree machines"}

It is straightforward to implement Turing machines as tree-machines: fixing a coding for the alphabet, we arrange the tree to be a pair of lists of symbols representing the tape left and right of the head respectively.

All Turing machine instructions are implemented in constant time:
{itemize [
  "Write symbol {mathsf$a$} under the head: <%(x,(\_,y)) => (x,(%{mathsf$a$}%,y)) | (x,()) => (x,(%{mathsf$a$}%,()))%> (the second case extends the tape if we reached the end)";
  "Move right: <%(x,(y,z)) => ((x,y),z)%>";
  "Move left: <%((x,y),z) => (x,(y,z))%>";
  "Check that symbol {mathsf$a$} is under the head: <%(\_,(%{mathsf$a$}%,\_)) => emptyact%>";
]}

So a Turing machine is translated to a tree machine with the same state and transitions labelled as above.

{subsection"A finite type for tree machines"}

The zipper allow us to build a finite set <%Psi%> of instruction which is complete with respect to tree machines, we write <%[[i]]%> for the interpretation of <%i%> in this new set:

{itemize[
  "<%[[()]] = (\_,()) => emptyact %>";
  "<%[[epsilon]] = (x,\_) => (x,())%>";
  "<%[[pi_1]] = (x,(y,z)) => (x,y)%>";
  "<%[[pi_2]] = (x,(y,z)) => (x,z)%>";
  "<%[[delta]] = (x,y) => (x,(y,y))%>";
  "<%[[(i,j)]] = left.[[i]].up.right.[[j]].up%>";
 ]}

Every instruction <%i IN Phi%> can be implemented as <%open.[[i]].exit%>. The instructions in <%Psi%> observe the tree at depth at most <%3%> (<%up%> gives the upper bound).

(* arnaud:
Remark: more generally, we can implement <%(r,s)%> for any two machines <%r%> and <%s%> as <%left.(r1,r).up.right.(r1,s).up%>.
*)

{subsection"Tree machines as Turing machines"}

Translating tree machines into Turing machines is not as direct as the converse. One way to translate trees into word so that it fits a Turing machine tape is to use the Polish notations: we take the alphabet to be <%{%{mathsf$p$}%;%{mathsf$u$}%}%> (for {emph"pair"} and {emph"unit"} respectively). The tree <%((),((),()))%> is then translated to <%pspss%>.

To manage the Polish notation, we can take a two-tape Turing machine, the first tape holds the current tree, and the second tape can hold a stack to find the boundaries of the two subtrees to implement <%pi_1%> and <%pi_2%> or a buffer with the tree to copy to implement <%delta%>.

The instructions of tree machines are not translated as constant time machines. However, they are all in a polynomial <%P%> of the current size of the tape. Hence, if the complexity of a tree machine is <%O \(f n\)%>, then the corresponding Turing machine has complexity <%O \(P \(f n\) * f n\)%>, which is in the same complexity class.

Therefore, tree machines and Turing machines have the same complexity classes (we only discuss non-deterministic machines in this article, but there is a natural notion of deterministic tree machine, and the translation can be arranged to preserve determinism). However, the translation from tree machines to Turing machines is non-trivial both in term of slowdown of the translated machine and complexity of the translation itself. It would be quite hard to get an explicit description of the translation. On the other hand the translation of Turing machines into tree machines is quite direct. Tree machines are a significant improvement over Turing machines.

{subsection"Tree machines as random access machines"}

A more natural encoding of Tree machines is in random access machines -- another example of Eilenberg machine. In this translation, a tree is an address at this address there is <%0%> if the tree is empty, and <%1%> if the tree is a pair. In the latter the two following addresses contain the addresses of the two subtrees.

In this translation, it is easy to implement the instructions of the tree machine as they are just pointer dereferencing and copy. The difficulties are:
{itemize[
  "Memory allocation: finding empty space to store a tree";
  "Garbage collection: to keep the same memory profile";
]}
Both are linear in a random access machine.

Memory allocation and garbage collection are usually assumed away in modern programming language, making the Tree machine a good complexity model of modern programming languages. On the other hand, it does not have constant-time-access arrays, which the random access machines provides and are available in programming language -- except purely functional ones.

{subsection"Encoding {lambda}-calculus"}

Using explicit substitution {lambda}{upsilon}-calculus~{citation_needed}:
{itemize[
  "$({lambda}u)v = u[v]$";
  "$({lambda}u)[s] = {lambda}(u[{uparrow_}s])$";
  "$(u v)[s] = (u[s])(v[s])$";
  "$0[v] = v$";
  "$(n+1)[v] = n+1$";
  "$0[{uparrow_}s] = 0$";
  "$(n+1)[{uparrow_}s] = n[s][{uparrow}]$";
  "$n[{uparrow}s] = n+1$";
]}

We will use the non-determinism of tree machines to represent the non-determinism of {beta}-reduction (the converse is not possible).

We fix an encoding for the following list of symbols <%{lam;app;succ;nought;subst;term;lift;shift}%>. First we need zipper-like constructions to navigate through terms:
{itemize [
  "<%open = u => ((),u)%>";
  "<%down_lam = (c,(lam,u)) => ((c,lam),u)%>";
  "<%down_sigma = (c,(subst,(u,s))) => ((c,(subst,s)),u)%>";
  "<%left = (c,(app,(u,v))) => ((c,(app,(0,v))),u)%>";
  "<%right = (c,(app,(u,v))) => ((c,(app,(1,u))),v)%>";
  "<%up_lam = ((c,lam),u) => (c,(lam,u))%>";
  "<%up_sigma = ((c,(subst,s)),u) => (c,(subst,(u,s)))%>";
  "<%up_app = ((c,(app,(0,v))),u) => (c,(app,(u,v))) | ((c,(app,(1,u))),v) => (c,(app,(u,v)))%>";
  "<%up = up_lam+up_sigma+up_app%>";
  "<%exit = ((),u) => u%>";
  "<%move = down_lam+down_sigma+left+right+up%>";
  "<%zip = up^*.exit%>";
 ]}
Now we implement the rules in a context independent manner:
{itemize [
  "<%beta = (app,((lam,u),v)) => (subst,(u,(term,v)))%>";
  "<%lam_sigma = (subst,((lam,u),s)) => (lam,(subst,(u,(lift,s))))%>";
  "<%app_sigma = (subst,((app,(u,v)),s)) => (app,((subst,(u,s)),(subst,(v,s))))%>";
  "<%nought_term = (subst,(nought,(term,v))) => v%>";
  "<%succ_term = (subst,((succ,n),(term,\_))) => succ n%>";
  "<%nought_lift = (subst,(nought,(lift,\_))) => nought%>";
  "<%succ_lift = (subst,((succ,n),(lift,s))) => (subst,((subst,(x,s)),shift))%>";
  "<%var_shift = (subst,(nought,shift)) => (succ,nought) | (subst,((succ,n),shift)) => (succ,(succ,n))%>";
  "<%rule_sigma = lam_sigma+app_sigma+nought_term+succ_term+nought_lift+succ_lift+var_shift%>"; 
  "<%rule = beta+rule_sigma%>";
]}
A step of {lambda}{upsilon}-calculus is implemented as:
{itemize[
  "<%step = open.move^*.(1,rule).zip%>";
]}
Reduction is then <%step^*%>.

To better represent actual {lambda}-calculus, a step of reduction should correspond to exactly one {beta}-reduction and substitutions should be eliminated. To do so we extend or alphabet of symbol with a symbol <%ok%> together with the following rules:
{itemize[
  "<%nought_ok = nought => (ok,nought)%>";
  "<%succ_ok = (succ,n) => (ok,(succ,n))%>";
  "<%lam_ok = (lam,(ok,u)) => (ok,(lam,u))%>";
  "<%app_ok = (app,((ok,u),(ok,v))) => (ok,(app,(u,v)))%>";
  "<%rule_ok = nought_ok+succ_ok+lam_ok+app_ok%>";
  "<%check_ok = (ok,u) => u%>";
]}
Then, we can encode a step of {lambda}-calculus with:
{itemize[
  "<%step = open.move^*.(1,beta.rule_sigma^*.rule_ok^*.check_ok).zip%>";
]}
"

(*** Emit document ***)

let d = concat [
  paragraph"Abstract"^^abstract;
  eilenberg;
  definition;
  translations;  
]

let funding =
  "This research has received funding from the European Research Council under the FP7 grant agreement 278673, Project MemCAD"

let title = "The tree machine{footnote funding}"

let author = "Arnaud Spiwack"

let packages = [
  "inputenc" , "utf8" ;
  "fontenc" , "T1" ;
  "textcomp", "";
  "microtype" , "" ;
]

let prelude = concat_with_sep [
  usepackage "hyperref";
  text\"\\\\let\\\\oldampersand\\\\&\";
  text\"\\\\renewcommand*\\\\&{{\\\\itshape\\\\oldampersand}}\";
  command \"bibliographystyle\" [T,"plain"] T;
] par

let file = \"treemachine.tex\"


let _ = emit ~file (document
                             ~title
                             ~author
                             ~prelude
                             ~packages
                             d)
